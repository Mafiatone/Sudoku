<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sudoku â€“ Ad-free</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050816;
      --bg-card: #070b18;
      --bg-card-soft: #0b1120;
      --text-main: #f9fafb;
      --text-muted: #9ca3af;

      --accent: #fbbf24;
      --accent-soft: rgba(251,191,36,0.25);

      --grid-line: #111827;
      --grid-line-bold: #1f2937;

      --given: #e5e7eb;
      --entry: #f9fafb;
      --note: #9ca3af;

      /* Selection + matching highlights â€“ brighter now */
      --related: rgba(148,163,184,0.40);
      --selected: rgba(56,189,248,0.65);
      --highlight-number: rgba(251,191,36,0.60);

      --error-bg: #facc15;
      --error-text: #111827;
    }

    /* THEMES â€“ punchy neon */

    body.theme-neon-green {
      --accent: #22c55e;
      --accent-soft: rgba(34,197,94,0.55);
      --grid-line: #16a34a;
      --grid-line-bold: #bbf7d0;
      --highlight-number: rgba(74,222,128,0.70);
      --selected: rgba(45,212,191,0.75);
      --related: rgba(45,212,191,0.35);
    }

    body.theme-neon-pink {
      --accent: #fb37a3;
      --accent-soft: rgba(251,55,163,0.65);
      --grid-line: #db2777;
      --grid-line-bold: #f9a8d4;
      --highlight-number: rgba(251,113,133,0.75);
      --selected: rgba(244,114,182,0.75);
      --related: rgba(244,114,182,0.35);
    }

    body.theme-neon-yellow {
      --accent: #facc15;
      --accent-soft: rgba(250,204,21,0.6);
      --grid-line: #f59e0b;
      --grid-line-bold: #fef9c3;
      --highlight-number: rgba(250,204,21,0.8);
      --selected: rgba(252,211,77,0.75);
      --related: rgba(252,211,77,0.35);
    }

    body.theme-high-contrast {
      --bg: #000000;
      --bg-card: #030712;
      --bg-card-soft: #020617;
      --text-main: #ffffff;
      --text-muted: #9ca3af;
      --accent: #f97316;
      --accent-soft: rgba(249,115,22,0.55);
      --grid-line: #4b5563;
      --grid-line-bold: #e5e7eb;
      --highlight-number: rgba(249,115,22,0.8);
      --selected: rgba(52,211,153,0.8);
      --related: rgba(148,163,184,0.45);
    }

    body.theme-christmas {
      --accent: #22c55e;
      --accent-soft: rgba(34,197,94,0.60);
      --grid-line: #14532d;
      --grid-line-bold: #b91c1c;
      --highlight-number: rgba(34,197,94,0.80);
      --selected: rgba(239,68,68,0.70);
      --related: rgba(252,211,77,0.40);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      color: var(--text-main);
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 12px;
    }

    .app-shell {
      margin: auto;
      width: 100%;
      max-width: 440px;
      background: radial-gradient(circle at top, #020617 0, #020617 45%, #000 100%);
      border-radius: 32px;
      padding: 18px 18px 20px;
      box-shadow:
        0 35px 120px rgba(0,0,0,0.95),
        0 0 0 1px rgba(15,23,42,0.9);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 8px;
    }
    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: 0.03em;
    }
    .subtitle {
      font-size: 11px;
      color: var(--text-muted);
    }
    .pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      color: var(--accent);
      background: radial-gradient(circle at top left, rgba(251,191,36,0.15), rgba(15,23,42,0.8));
      white-space: nowrap;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .select-wrap {
      position: relative;
      flex: 1 1 0;
      min-width: 0;
    }
    .select-wrap select {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.95), rgba(15,23,42,0.9));
      color: var(--text-main);
      padding: 7px 28px 7px 11px;
      font-size: 12px;
    }
    .select-wrap::after {
      content: "â–¾";
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      color: var(--text-muted);
      pointer-events: none;
    }

    .btn-primary {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: radial-gradient(circle at 30% 0,
        #fee2e2 0,
        var(--accent) 40%,
        #a855f7 100%);
      color: #111827;
      font-weight: 600;
      font-size: 12px;
      box-shadow:
        0 0 0 1px rgba(15,23,42,0.8),
        0 10px 30px rgba(0,0,0,0.9),
        0 0 18px var(--accent-soft);
      white-space: nowrap;
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--text-muted);
      gap: 10px;
    }
    .status-left {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }
    .status-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 2px rgba(22,163,74,0.3);
      flex-shrink: 0;
    }
    .status-message {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .status-right {
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }

    .board-wrap {
      margin-top: 4px;
      margin-bottom: 10px;
      background: radial-gradient(circle at top, rgba(15,23,42,1) 0, rgba(15,23,42,0.98) 30%, #020617 100%);
      border-radius: 26px;
      padding: 14px;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,0.9),
        0 25px 60px rgba(0,0,0,0.9);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 0;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(15,23,42,0.9);
    }

    .cell {
      position: relative;
      width: 100%;
      padding-bottom: 100%;
      background: radial-gradient(circle at top, #020617 0, #020617 60%, #020617 100%);
      border: 1px solid var(--grid-line);
      color: var(--entry);
      font-weight: 500;
      cursor: pointer;
      text-align: center;
      font-size: 18px;
      transition: box-shadow 0.15s ease-out;
    }

    .cell-inner {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cell.given {
      color: var(--given);
      font-weight: 600;
    }

    .cell.selected::before,
    .cell.related::before,
    .cell.same-number::before {
      content: "";
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    .cell.selected::before {
      background: var(--selected);
    }

    .cell.related:not(.selected)::before {
      background: var(--related);
    }

    .cell.same-number:not(.selected)::before {
      background: var(--highlight-number);
    }

    .cell-error::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--error-bg);
      opacity: 0.95;
      z-index: 0;
    }
    .cell-error .cell-inner {
      color: var(--error-text);
      font-weight: 700;
      z-index: 1;
    }

    .cell.note .cell-inner {
      font-size: 9px;
      line-height: 1.1;
      white-space: pre-line;
      color: var(--note);
      font-weight: 500;
    }

    .cell.border-right-bold {
      border-right: 2px solid var(--grid-line-bold);
    }
    .cell.border-bottom-bold {
      border-bottom: 2px solid var(--grid-line-bold);
    }

    .keypad {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
    }

    .key {
      border-radius: 999px;
      padding: 10px 0;
      border: 1px solid rgba(55,65,81,0.9);
      background: radial-gradient(circle at top, #020617 0, #020617 60%, #020617 100%);
      color: var(--text-main);
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(15,23,42,0.9),
        0 10px 25px rgba(0,0,0,0.8);
    }
    .key.disabled {
      opacity: 0.18;
      pointer-events: none;
    }

    .key-primary {
      background: radial-gradient(circle at 30% 0,
        #fed7aa 0,
        var(--accent) 45%,
        #ec4899 100%);
      color: #111827;
      font-weight: 700;
    }

    .key-wide {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .key-toggle.active {
      border-color: var(--accent);
      box-shadow:
        0 0 0 1px var(--accent-soft),
        0 10px 25px rgba(0,0,0,0.9),
        inset 0 0 0 1px rgba(0,0,0,0.8);
    }

    .footer-row {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 10px;
      color: var(--text-muted);
      gap: 6px;
    }

    .link {
      color: #22c55e;
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
    }

    .version {
      opacity: 0.65;
      margin-left: 4px;
    }

    /* Stats modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }
    .modal-backdrop.show {
      display: flex;
    }
    .modal {
      background: radial-gradient(circle at top, #020617 0, #020617 45%, #020617 100%);
      border-radius: 24px;
      padding: 18px 18px 16px;
      width: min(380px, 100% - 32px);
      box-shadow:
        0 25px 60px rgba(0,0,0,0.95),
        0 0 0 1px rgba(15,23,42,0.9);
      font-size: 12px;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .modal-title {
      font-size: 18px;
      font-weight: 600;
    }
    .badge-row {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .stat-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 6px;
      font-variant-numeric: tabular-nums;
    }
    .stat-table th,
    .stat-table td {
      padding: 4px 0;
    }
    .stat-table th {
      font-size: 11px;
      color: var(--text-muted);
      text-align: left;
      border-bottom: 1px solid rgba(55,65,81,0.9);
    }
    .stat-table td {
      font-size: 12px;
    }
    .stat-table td:first-child {
      color: var(--text-muted);
    }
    .modal-footer {
      margin-top: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-muted);
    }
    .btn-small {
      padding: 5px 12px;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: #020617;
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
    }

    /* Completion animation overlay (for confetti) */
    .anim-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
      overflow: hidden;
    }
    .anim-confetti-piece {
      position: absolute;
      width: 6px;
      height: 10px;
      border-radius: 999px;
      background: #fbbf24;
      opacity: 0.95;
      animation: confetti-fall 1.3s ease-out forwards;
    }
    @keyframes confetti-fall {
      from { transform: translate3d(var(--sx), -40px, 0) rotate(0deg); opacity: 0; }
      15% { opacity: 1; }
      to { transform: translate3d(var(--sx), 260px, 0) rotate(240deg); opacity: 0; }
    }

    /* Cell-based completion animations */

    .cell-anim-glow {
      animation: cellGlow 0.6s ease-in-out;
    }
    @keyframes cellGlow {
      0%   { box-shadow: 0 0 0 0 rgba(251,191,36,0.0); }
      30%  { box-shadow: 0 0 14px 4px rgba(251,191,36,0.9); }
      100% { box-shadow: 0 0 0 0 rgba(251,191,36,0.0); }
    }

    .cell-anim-tree {
      animation: cellTree 0.7s ease-in-out;
    }
    @keyframes cellTree {
      0%   { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
      25%  { box-shadow: 0 0 12px 4px rgba(34,197,94,0.95); }
      55%  { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
      80%  { box-shadow: 0 0 12px 4px rgba(239,68,68,0.95); }
      100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); }
    }

    @media (max-width: 420px) {
      .app-shell {
        border-radius: 26px;
        padding: 14px 12px 16px;
      }
      h1 {
        font-size: 22px;
      }
      .subtitle {
        font-size: 10px;
      }
      .controls-row {
        gap: 6px;
      }
      .btn-primary {
        padding-inline: 12px;
      }
    }
  </style>
</head>
<body class="theme-neon-green">
  <div class="app-shell">
    <header>
      <div class="title-wrap">
        <h1>Sudoku</h1>
        <div class="subtitle">Ad-free. Just numbers and logic.</div>
      </div>
      <div class="pill">No ads. No accounts.</div>
    </header>

    <div class="controls-row">
      <div class="select-wrap">
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="expert">Expert</option>
          <option value="master">Master</option>
          <option value="extreme">Extreme</option>
          <option value="impossible">Impossible</option>
        </select>
      </div>
      <div class="select-wrap">
        <select id="theme">
          <option value="neon-green" selected>Neon Green</option>
          <option value="neon-pink">Neon Pink</option>
          <option value="neon-yellow">Neon Yellow</option>
          <option value="high-contrast">High Contrast</option>
          <option value="christmas">Christmas</option>
        </select>
      </div>
      <div class="select-wrap">
        <select id="animation">
          <option value="grid" selected>Grid Glow</option>
          <option value="tree">Tree Lights</option>
          <option value="confetti">Confetti</option>
          <option value="off">Off</option>
        </select>
      </div>
      <button id="newPuzzleBtn" class="btn-primary">NEW</button>
    </div>

    <div class="status-row">
      <div class="status-left">
        <div class="status-dot" id="statusDot"></div>
        <div class="status-message" id="statusMessage">In progress</div>
      </div>
      <div class="status-right" id="timer">00:00</div>
    </div>

    <div class="board-wrap">
      <div id="grid" class="grid"></div>
    </div>

    <div class="keypad">
      <button class="key num-key" data-num="1">1</button>
      <button class="key num-key" data-num="2">2</button>
      <button class="key num-key" data-num="3">3</button>
      <button class="key num-key" data-num="4">4</button>
      <button class="key num-key" data-num="5">5</button>
      <button class="key num-key" data-num="6">6</button>
      <button class="key num-key" data-num="7">7</button>
      <button class="key num-key" data-num="8">8</button>
      <button class="key num-key" data-num="9">9</button>
      <button class="key key-wide" id="eraseKey">ERASE</button>

      <button class="key key-toggle key-wide" id="notesKey">NOTES</button>
      <button class="key key-wide" id="clearNotesKey">CLR NOTES</button>
      <button class="key key-wide" id="checkKey">CHECK</button>
      <button class="key key-wide" id="undoKey">UNDO</button>
      <button class="key key-primary" id="hintKey">HINT</button>
    </div>

    <div class="footer-row">
      <div>
        <span>Progress is saved locally.</span>
        <span class="version">v1.00</span>
      </div>
      <div class="link" id="statsLink">Stats</div>
    </div>
  </div>

  <div class="anim-overlay" id="animOverlay"></div>

  <div class="modal-backdrop" id="statsModal">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">Stats</div>
        <button class="btn-small" id="closeStatsBtn">Close</button>
      </div>
      <div class="badge-row" id="badgeRow">
        Badges â€“ No Hints: 0 Â· No Errors: 0 Â· Perfect: 0
      </div>
      <table class="stat-table">
        <thead>
          <tr>
            <th>Level</th>
            <th>Games</th>
            <th>Best</th>
            <th>Avg</th>
            <th>Worst</th>
          </tr>
        </thead>
        <tbody id="statsBody"></tbody>
      </table>
      <div class="modal-footer">
        <div id="totalsRow">Total games: 0 Â· Streak: 0 day(s)</div>
        <button class="btn-small" id="resetStatsBtn">Reset</button>
      </div>
    </div>
  </div>

  <script>
    /* ---------------- Difficulty config & generator ---------------- */

    const DIFFICULTY_CONFIG = {
      easy:       { minClues: 40, maxClues: 45, minRow: 3, minCol: 3, minBox: 4 },
      medium:     { minClues: 36, maxClues: 39, minRow: 3, minCol: 3, minBox: 3 },
      hard:       { minClues: 32, maxClues: 35, minRow: 2, minCol: 2, minBox: 2 },
      expert:     { minClues: 28, maxClues: 31, minRow: 2, minCol: 2, minBox: 2 },
      master:     { minClues: 25, maxClues: 27, minRow: 2, minCol: 2, minBox: 2 },
      extreme:    { minClues: 22, maxClues: 24, minRow: 1, minCol: 1, minBox: 1 },
      impossible: { minClues: 17, maxClues: 21, minRow: 1, minCol: 1, minBox: 1 }
    };

    const DIFFICULTY_KEYS = [
      "easy","medium","hard","expert","master","extreme","impossible"
    ];

    const STORAGE_KEY_STATE = "sudoku_v100_state";
    const STORAGE_KEY_STATS = "sudoku_stats_v1";

    const gridEl = document.getElementById("grid");
    const difficultySelect = document.getElementById("difficulty");
    const themeSelect = document.getElementById("theme");
    const animSelect = document.getElementById("animation");
    const newBtn = document.getElementById("newPuzzleBtn");
    const statusMessageEl = document.getElementById("statusMessage");
    const statusDotEl = document.getElementById("statusDot");
    const timerEl = document.getElementById("timer");
    const notesKey = document.getElementById("notesKey");
    const clearNotesKey = document.getElementById("clearNotesKey");
    const checkKey = document.getElementById("checkKey");
    const undoKey = document.getElementById("undoKey");
    const eraseKey = document.getElementById("eraseKey");
    const hintKey = document.getElementById("hintKey");
    const statsLink = document.getElementById("statsLink");
    const statsModal = document.getElementById("statsModal");
    const closeStatsBtn = document.getElementById("closeStatsBtn");
    const resetStatsBtn = document.getElementById("resetStatsBtn");
    const statsBody = document.getElementById("statsBody");
    const badgeRow = document.getElementById("badgeRow");
    const totalsRow = document.getElementById("totalsRow");
    const animOverlay = document.getElementById("animOverlay");

    const numKeys = Array.from(document.querySelectorAll(".num-key"));

    let cells = [];
    let board = [];
    let givens = [];
    let notes = [];
    let solution = [];
    let errors = [];
    let selectedCell = null;
    let notesMode = false;
    let timerId = null;
    let startTimestamp = null;
    let elapsedSeconds = 0;
    let undoStack = [];
    let errorCount = 0;
    let hintCount = 0;
    let currentDifficulty = difficultySelect.value;

    /* ---------------- Utility ---------------- */

    function timeToString(sec) {
      sec = Math.max(0, Math.round(sec));
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function randChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randInt(min, max) {
      return min + Math.floor(Math.random() * (max - min + 1));
    }

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function cloneBoard(b) {
      return b.map(row => row.slice());
    }

    function boxIndex(r,c) {
      return Math.floor(r/3)*3 + Math.floor(c/3);
    }

    /* ---------------- Solver & generator ---------------- */

    function findEmpty(b) {
      for (let r = 0; r < 9; r++)
        for (let c = 0; c < 9; c++)
          if (b[r][c] === "0") return [r,c];
      return null;
    }

    function isValidPlacement(b,r,c,v) {
      for (let i=0;i<9;i++) {
        if (b[r][i] === v) return false;
        if (b[i][c] === v) return false;
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let rr=br; rr<br+3; rr++)
        for (let cc=bc; cc<bc+3; cc++)
          if (b[rr][cc] === v) return false;
      return true;
    }

    function solveOne(boardIn) {
      const b = cloneBoard(boardIn);
      function backtrack() {
        const pos = findEmpty(b);
        if (!pos) return true;
        const [r,c] = pos;
        let digits = ["1","2","3","4","5","6","7","8","9"];
        digits = shuffleArray(digits);
        for (const v of digits) {
          if (isValidPlacement(b,r,c,v)) {
            b[r][c] = v;
            if (backtrack()) return true;
            b[r][c] = "0";
          }
        }
        return false;
      }
      if (!backtrack()) return null;
      return b;
    }

    function countSolutions(boardIn, maxCount=2) {
      const b = cloneBoard(boardIn);
      let count = 0;
      function backtrack() {
        if (count >= maxCount) return;
        const pos = findEmpty(b);
        if (!pos) {
          count++;
          return;
        }
        const [r,c] = pos;
        for (let d=1; d<=9; d++) {
          const v = String(d);
          if (isValidPlacement(b,r,c,v)) {
            b[r][c] = v;
            backtrack();
            b[r][c] = "0";
            if (count >= maxCount) return;
          }
        }
      }
      backtrack();
      return count;
    }

    function generateSolvedBoard() {
      const empty = Array.from({length:9}, () =>
        Array.from({length:9}, () => "0")
      );
      const solved = solveOne(empty);
      return solved;
    }

    function generatePuzzle(difficultyKey) {
      const cfg = DIFFICULTY_CONFIG[difficultyKey] || DIFFICULTY_CONFIG.medium;
      const targetClues = randInt(cfg.minClues, cfg.maxClues);

      const solved = generateSolvedBoard();
      const puzzle = cloneBoard(solved);

      const rowCount = Array(9).fill(9);
      const colCount = Array(9).fill(9);
      const boxCount = Array(9).fill(9);

      let clues = 81;

      const positions = [];
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++)
          positions.push([r,c]);
      shuffleArray(positions);

      for (const [r,c] of positions) {
        if (clues <= targetClues) break;
        if (puzzle[r][c] === "0") continue;

        const bx = boxIndex(r,c);
        if (rowCount[r] <= cfg.minRow) continue;
        if (colCount[c] <= cfg.minCol) continue;
        if (boxCount[bx] <= cfg.minBox) continue;

        const saved = puzzle[r][c];
        puzzle[r][c] = "0";
        rowCount[r]--;
        colCount[c]--;
        boxCount[bx]--;
        clues--;

        const solCount = countSolutions(puzzle, 2);
        if (solCount !== 1) {
          // revert
          puzzle[r][c] = saved;
          rowCount[r]++;
          colCount[c]++;
          boxCount[bx]++;
          clues++;
        }
      }

      return { puzzle, solution: solved };
    }

    /* ---------------- Grid & rendering ---------------- */

    function buildGrid() {
      gridEl.innerHTML = "";
      cells = [];
      for (let r=0;r<9;r++) {
        const row = [];
        for (let c=0;c<9;c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          if (c===2 || c===5) cell.classList.add("border-right-bold");
          if (r===2 || r===5) cell.classList.add("border-bottom-bold");
          const inner = document.createElement("div");
          inner.className = "cell-inner";
          cell.appendChild(inner);
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", () => onCellClick(cell));
          gridEl.appendChild(cell);
          row.push(cell);
        }
        cells.push(row);
      }
    }

    function initErrorGrid() {
      errors = [];
      for (let r=0;r<9;r++) {
        const row = [];
        for (let c=0;c<9;c++) row.push(false);
        errors.push(row);
      }
    }

    function applyBoardToUI() {
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const cell = cells[r][c];
          const inner = cell.firstChild;
          const v = board[r][c];

          // reset to base class + 3x3 borders
          cell.className = "cell";
          if (c===2 || c===5) cell.classList.add("border-right-bold");
          if (r===2 || r===5) cell.classList.add("border-bottom-bold");

          inner.textContent = "";
          if (givens[r][c]) cell.classList.add("given");
          if (v !== "0") {
            inner.textContent = v;
          } else if (notes[r][c].size) {
            cell.classList.add("note");
            inner.textContent = [...notes[r][c]].sort().join(" ");
          }
          if (errors[r][c]) {
            cell.classList.add("cell-error");
          }
        }
      }
      updateKeypadVisibility();
      refreshHighlights();
    }

    function startNewGame(fromUserClick=false) {
      if (fromUserClick) pushStateToHistory();

      currentDifficulty = difficultySelect.value;

      const { puzzle, solution: solved } = generatePuzzle(currentDifficulty);
      solution = solved;
      board = cloneBoard(puzzle);

      givens = [];
      notes = [];
      for (let r=0;r<9;r++) {
        const gRow = [];
        const nRow = [];
        for (let c=0;c<9;c++) {
          gRow.push(board[r][c] !== "0");
          nRow.push(new Set());
        }
        givens.push(gRow);
        notes.push(nRow);
      }

      initErrorGrid();
      selectedCell = null;
      notesMode = false;
      notesKey.classList.remove("active");
      errorCount = 0;
      hintCount = 0;
      elapsedSeconds = 0;
      startTimestamp = Date.now();
      clearTimer();
      startTimer();
      statusMessageEl.textContent = "In progress";
      statusDotEl.style.background = "#22c55e";
      undoStack = [];
      applyBoardToUI();
      saveState();
    }

    function startTimer() {
      timerId = setInterval(() => {
        const now = Date.now();
        elapsedSeconds = Math.floor((now - startTimestamp) / 1000);
        timerEl.textContent = timeToString(elapsedSeconds);
      },1000);
    }
    function clearTimer() { if (timerId) clearInterval(timerId); timerId=null; }

    function onCellClick(cell) {
      selectedCell = cell;
      refreshHighlights();
    }

    function refreshHighlights() {
      const selectedVal = selectedCell
        ? board[selectedCell.dataset.row][selectedCell.dataset.col]
        : null;
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const cell = cells[r][c];
          cell.classList.remove("selected","related","same-number");
          if (selectedCell && cell === selectedCell) {
            cell.classList.add("selected");
            continue;
          }
          if (selectedCell) {
            if (Number(cell.dataset.row) === Number(selectedCell.dataset.row) ||
                Number(cell.dataset.col) === Number(selectedCell.dataset.col) ||
                (Math.floor(r/3) === Math.floor(selectedCell.dataset.row/3) &&
                 Math.floor(c/3) === Math.floor(selectedCell.dataset.col/3))) {
              cell.classList.add("related");
            }
            const cellVal = board[r][c];
            if (cellVal !== "0" && cellVal === selectedVal) {
              cell.classList.add("same-number");
            }
          }
        }
      }
    }

    function recomputeErrors(countNewErrors=false, lastR=null, lastC=null) {
      let anyError = false;
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const prev = errors[r][c];
          const v = board[r][c];
          const isErr = (v !== "0" && solution[r][c] !== v);
          errors[r][c] = isErr;
          if (isErr) {
            anyError = true;
            if (countNewErrors && !prev && r===lastR && c===lastC) {
              errorCount++;
            }
          }
        }
      }
      applyBoardToUI();
      if (anyError) {
        statusMessageEl.textContent = "That breaks row / column / box.";
        statusDotEl.style.background = "#fbbf24";
      } else {
        statusMessageEl.textContent = "In progress";
        statusDotEl.style.background = "#22c55e";
      }
      return anyError;
    }

    /* ---------------- Input handling ---------------- */

    function handleNumberInput(num) {
      if (!selectedCell) return;
      const r = Number(selectedCell.dataset.row);
      const c = Number(selectedCell.dataset.col);
      if (givens[r][c]) return;

      pushStateToHistory();

      if (notesMode) {
        const set = notes[r][c];
        if (set.has(num)) set.delete(num); else set.add(num);
        applyBoardToUI();
        recomputeErrors(false);
        saveState();
        return;
      }

      notes[r][c].clear();
      board[r][c] = num;
      autoClearNotes(r,c,num);

      recomputeErrors(true, r, c);
      saveState();
      checkCompletion();
    }

    function autoClearNotes(r,c,num) {
      for (let i=0;i<9;i++) {
        notes[r][i].delete(num);
        notes[i][c].delete(num);
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let rr=br; rr<br+3; rr++)
        for (let cc=bc; cc<bc+3; cc++)
          notes[rr][cc].delete(num);
    }

    function handleErase() {
      if (!selectedCell) return;
      const r = Number(selectedCell.dataset.row);
      const c = Number(selectedCell.dataset.col);
      if (givens[r][c]) return;
      if (board[r][c] === "0" && notes[r][c].size === 0) return;
      pushStateToHistory();
      board[r][c] = "0";
      notes[r][c].clear();
      recomputeErrors(false);
      saveState();
    }

    function handleClearNotes() {
      pushStateToHistory();
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++)
          if (!givens[r][c]) notes[r][c].clear();
      recomputeErrors(false);
      saveState();
    }

    function toggleNotesMode() {
      notesMode = !notesMode;
      notesKey.classList.toggle("active", notesMode);
      updateKeypadVisibility();
    }

    function handleCheck() {
      const hasErrors = recomputeErrors(false);
      if (!hasErrors) {
        statusMessageEl.textContent = "No issues so far.";
        statusDotEl.style.background = "#22c55e";
      }
    }

    function pushStateToHistory() {
      const snapshot = {
        board: board.map(r => r.slice()),
        notes: notes.map(row => row.map(set => new Set(set))),
        errors: errors.map(r => r.slice()),
        elapsedSeconds,
        errorCount,
        hintCount
      };
      undoStack.push(snapshot);
      if (undoStack.length > 100) undoStack.shift();
    }

    function handleUndo() {
      const snap = undoStack.pop();
      if (!snap) return;
      board = snap.board.map(r => r.slice());
      notes = snap.notes.map(row => row.map(set => new Set(set)));
      errors = snap.errors.map(r => r.slice());
      elapsedSeconds = snap.elapsedSeconds;
      errorCount = snap.errorCount;
      hintCount = snap.hintCount;
      timerEl.textContent = timeToString(elapsedSeconds);
      startTimestamp = Date.now() - elapsedSeconds*1000;
      applyBoardToUI();
      recomputeErrors(false);
      saveState();
    }

    function handleHint() {
      const emptyCells = [];
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++)
          if (!givens[r][c] && board[r][c] === "0")
            emptyCells.push([r,c]);
      if (!emptyCells.length) return;
      pushStateToHistory();
      const [r,c] = randChoice(emptyCells);
      const correct = solution[r][c];
      board[r][c] = correct;
      notes[r][c].clear();
      autoClearNotes(r,c,correct);
      hintCount++;
      recomputeErrors(false);
      saveState();
      checkCompletion();
    }

    /* ---------------- Completion & keypad ---------------- */

    function isBoardComplete() {
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++)
          if (board[r][c] === "0") return false;
      return true;
    }
    function allCellsCorrect() {
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++)
          if (board[r][c] !== solution[r][c]) return false;
      return true;
    }

    function checkCompletion() {
      if (!isBoardComplete()) {
        updateKeypadVisibility();
        return;
      }
      recomputeErrors(false);
      if (!allCellsCorrect()) {
        statusMessageEl.textContent = "Board full, but with mistakes.";
        statusDotEl.style.background = "#f97316";
        updateKeypadVisibility();
        return;
      }
      clearTimer();
      statusMessageEl.textContent = "Completed ðŸŽ‰";
      statusDotEl.style.background = "#22c55e";
      recordStats();
      playCompletionAnimation();
      updateKeypadVisibility(true);
      saveState(true);
    }

    function updateKeypadVisibility(forceShowAll=false) {
      if (notesMode || forceShowAll) {
        numKeys.forEach(k => k.classList.remove("disabled"));
        return;
      }
      const counts = Array(10).fill(0);
      for (let r=0;r<9;r++)
        for (let c=0;c<9;c++) {
          const v = board[r][c];
          if (v !== "0" && !errors[r][c]) counts[Number(v)]++;
        }
      numKeys.forEach(k => {
        const n = Number(k.dataset.num);
        if (counts[n] >= 9) k.classList.add("disabled");
        else k.classList.remove("disabled");
      });
    }

    function playCompletionAnimation() {
      const mode = animSelect.value;
      if (mode === "off") return;

      if (mode === "confetti") {
        animOverlay.innerHTML = "";
        for (let i=0;i<80;i++) {
          const piece = document.createElement("div");
          piece.className = "anim-confetti-piece";
          const hue = 40 + Math.random()*280;
          piece.style.background = `hsl(${hue}, 90%, 60%)`;
          piece.style.left = `${Math.random()*100}%`;
          piece.style.setProperty("--sx", `${(Math.random()-0.5)*60}px`);
          animOverlay.appendChild(piece);
        }
        setTimeout(() => { animOverlay.innerHTML = ""; }, 1400);
        return;
      }

      if (mode === "grid") {
        let delay = 0;
        for (let r=0;r<9;r++) {
          for (let c=0;c<9;c++) {
            const cell = cells[r][c];
            setTimeout(() => {
              cell.classList.add("cell-anim-glow");
              setTimeout(() => cell.classList.remove("cell-anim-glow"), 650);
            }, delay);
            delay += 35;
          }
        }
        return;
      }

      if (mode === "tree") {
        const pattern = [
          [0,4],
          [1,3],[1,4],[1,5],
          [2,2],[2,3],[2,4],[2,5],[2,6],
          [3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],
          [4,2],[4,3],[4,4],[4,5],[4,6],
          [5,3],[5,4],[5,5],
          [6,4],
          [7,4]
        ];
        pattern.forEach(( [r,c], idx ) => {
          if (cells[r] && cells[r][c]) {
            const cell = cells[r][c];
            const delay = idx * 90;
            setTimeout(() => {
              cell.classList.add("cell-anim-tree");
              setTimeout(() => cell.classList.remove("cell-anim-tree"), 750);
            }, delay);
          }
        });
      }
    }

    /* ---------------- Stats ---------------- */

    function loadStats() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_STATS);
        if (!raw) {
          return {
            badges:{noHints:0,noErrors:0,perfect:0},
            streak:{days:0,lastDate:null},
            levels: DIFFICULTY_KEYS.reduce((acc,k)=>{acc[k]={times:[]};return acc;}, {})
          };
        }
        const parsed = JSON.parse(raw);
        if (!parsed.levels) parsed.levels = {};
        for (const key of DIFFICULTY_KEYS) {
          if (!parsed.levels[key]) parsed.levels[key] = {times:[]};
        }
        if (!parsed.badges) parsed.badges = {noHints:0,noErrors:0,perfect:0};
        if (!parsed.streak) parsed.streak = {days:0,lastDate:null};
        return parsed;
      } catch {
        return {
          badges:{noHints:0,noErrors:0,perfect:0},
          streak:{days:0,lastDate:null},
          levels: DIFFICULTY_KEYS.reduce((acc,k)=>{acc[k]={times:[]};return acc;}, {})
        };
      }
    }
    let stats = loadStats();

    function saveStats() {
      localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(stats));
    }

    function recordStats() {
      const level = currentDifficulty;
      if (!stats.levels[level]) stats.levels[level] = {times:[]};
      stats.levels[level].times.push({
        seconds: elapsedSeconds,
        errors: errorCount,
        hints: hintCount,
        finishedAt: new Date().toISOString().slice(0,10)
      });
      if (hintCount === 0) stats.badges.noHints++;
      if (errorCount === 0) stats.badges.noErrors++;
      if (hintCount === 0 && errorCount === 0) stats.badges.perfect++;

      const today = new Date().toISOString().slice(0,10);
      if (!stats.streak.lastDate) {
        stats.streak.lastDate = today;
        stats.streak.days = 1;
      } else if (stats.streak.lastDate !== today) {
        const last = new Date(stats.streak.lastDate);
        const cur = new Date(today);
        const diffDays = Math.round((cur-last)/(1000*60*60*24));
        if (diffDays === 1) stats.streak.days += 1;
        else if (diffDays > 1) stats.streak.days = 1;
        stats.streak.lastDate = today;
      }
      saveStats();
    }

    function formatTimeOrDash(v) { return (v || v===0) ? timeToString(v) : "â€”"; }

    function showStatsModal() {
      stats = loadStats();
      badgeRow.textContent =
        `Badges â€“ No Hints: ${stats.badges.noHints} Â· No Errors: ${stats.badges.noErrors} Â· Perfect: ${stats.badges.perfect}`;

      statsBody.innerHTML = "";
      let totalGames = 0;

      for (const lvl of DIFFICULTY_KEYS) {
        const rowData = stats.levels[lvl] || {times:[]};
        const times = rowData.times || [];
        totalGames += times.length;
        let best=null,worst=null,sum=0;
        for (const t of times) {
          const s=t.seconds;
          if (best===null || s<best) best=s;
          if (worst===null || s>worst) worst=s;
          sum+=s;
        }
        const avg = times.length ? Math.round(sum/times.length) : null;
        const niceName = lvl[0].toUpperCase()+lvl.slice(1);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${niceName}</td>
          <td>${times.length}</td>
          <td>${formatTimeOrDash(best)}</td>
          <td>${formatTimeOrDash(avg)}</td>
          <td>${formatTimeOrDash(worst)}</td>`;
        statsBody.appendChild(tr);
      }

      const streakDays = stats.streak.days || 0;
      totalsRow.textContent = `Total games: ${totalGames} Â· Streak: ${streakDays} day(s)`;
      statsModal.classList.add("show");
    }

    function closeStatsModal() { statsModal.classList.remove("show"); }

    function resetStats() {
      stats = {
        badges:{noHints:0,noErrors:0,perfect:0},
        streak:{days:0,lastDate:null},
        levels: DIFFICULTY_KEYS.reduce((acc,k)=>{acc[k]={times:[]};return acc;}, {})
      };
      saveStats();
      showStatsModal();
    }

    /* ---------------- State persistence ---------------- */

    function saveState(completed=false) {
      const state = {
        difficulty: currentDifficulty,
        theme: themeSelect.value,
        animation: animSelect.value,
        board,
        givens,
        notes: notes.map(row => row.map(set => [...set])),
        solution,
        errors,
        elapsedSeconds,
        startTimestamp: completed ? null : Date.now(),
        errorCount,
        hintCount,
        completed
      };
      try {
        localStorage.setItem(STORAGE_KEY_STATE, JSON.stringify(state));
      } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_STATE);
        if (!raw) return false;
        const state = JSON.parse(raw);
        if (!state || !state.board || !state.solution) return false;

        currentDifficulty = state.difficulty || "medium";
        difficultySelect.value = currentDifficulty;
        themeSelect.value = state.theme || "neon-green";
        animSelect.value = state.animation || "grid";
        applyTheme();

        board = state.board;
        givens = state.givens;
        notes = state.notes.map(row => row.map(arr => new Set(arr)));
        solution = state.solution;
        errors = state.errors || (initErrorGrid(), errors);
        elapsedSeconds = state.elapsedSeconds || 0;
        errorCount = state.errorCount || 0;
        hintCount = state.hintCount || 0;
        undoStack = [];

        applyBoardToUI();
        recomputeErrors(false);
        timerEl.textContent = timeToString(elapsedSeconds);

        if (!state.completed && state.startTimestamp) {
          startTimestamp = Date.now() - (elapsedSeconds*1000);
          clearTimer();
          startTimer();
          statusMessageEl.textContent = "In progress";
          statusDotEl.style.background = "#22c55e";
        } else if (state.completed) {
          statusMessageEl.textContent = "Completed ðŸŽ‰";
          statusDotEl.style.background = "#22c55e";
        }

        updateKeypadVisibility(state.completed);
        return true;
      } catch {
        return false;
      }
    }

    function applyTheme() {
      document.body.classList.remove(
        "theme-neon-green",
        "theme-neon-pink",
        "theme-neon-yellow",
        "theme-high-contrast",
        "theme-christmas"
      );
      document.body.classList.add("theme-" + themeSelect.value);
    }

    /* ---------------- Events & boot ---------------- */

    numKeys.forEach(btn => {
      btn.addEventListener("click", () => handleNumberInput(btn.dataset.num));
    });
    eraseKey.addEventListener("click", handleErase);
    notesKey.addEventListener("click", toggleNotesMode);
    clearNotesKey.addEventListener("click", handleClearNotes);
    checkKey.addEventListener("click", handleCheck);
    undoKey.addEventListener("click", handleUndo);
    hintKey.addEventListener("click", handleHint);

    difficultySelect.addEventListener("change", () => {
      currentDifficulty = difficultySelect.value;
      startNewGame(true);
    });
    themeSelect.addEventListener("change", () => {
      applyTheme();
      saveState();
    });
    animSelect.addEventListener("change", () => saveState());
    newBtn.addEventListener("click", () => startNewGame(true));
    statsLink.addEventListener("click", showStatsModal);
    closeStatsBtn.addEventListener("click", closeStatsModal);
    resetStatsBtn.addEventListener("click", resetStats);
    statsModal.addEventListener("click", (e)=>{ if(e.target===statsModal) closeStatsModal(); });

    buildGrid();
    if (!loadState()) {
      applyTheme();
      startNewGame(false);
    }
  </script>
</body>
</html>
