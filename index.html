<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sudoku â€“ Your Ad-Free App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      --bg: #111827;
      --card: #020617;
      --accent: #fbbf24;
      --grid-line: #374151;
      --grid-sub: #4b5563;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --error: #f97373;
      --given: #e5e7eb;
      --cell-bg: #020617;
      --cell-selected: #1d4ed8;
      --cell-related: #020617;
      --same-bg: rgba(250, 204, 21, 0.18);
      --same-border: rgba(250, 204, 21, 0.7);
      --same-text: #facc15;
    }

    /* THEMES */

    body.theme-classic {
      --bg: #111827;
      --card: #020617;
      --accent: #fbbf24;
      --grid-line: #374151;
      --grid-sub: #4b5563;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --error: #f97373;
      --given: #e5e7eb;
      --cell-bg: #020617;
      --cell-selected: #1d4ed8;
      --cell-related: #020617;
      --same-bg: rgba(250, 204, 21, 0.18);
      --same-border: rgba(250, 204, 21, 0.7);
      --same-text: #facc15;
    }

    body.theme-neon {
      --bg: #020617;
      --card: #020617;
      --accent: #22c55e;
      --grid-line: #22c55e;
      --grid-sub: #4ade80;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --error: #fb7185;
      --given: #f9fafb;
      --cell-bg: #020617;
      --cell-selected: #22c55e;
      --cell-related: #020617;
      --same-bg: rgba(34, 197, 94, 0.18);
      --same-border: rgba(34, 197, 94, 0.7);
      --same-text: #4ade80;
    }

    body.theme-neonpink {
      --bg: #020617;
      --card: #020617;
      --accent: #ec4899;
      --grid-line: #ec4899;
      --grid-sub: #fb7185;
      --text: #f9fafb;
      --muted: #e5e7eb;
      --error: #fb7185;
      --given: #fdf2f8;
      --cell-bg: #020617;
      --cell-selected: #ec4899;
      --cell-related: #020617;
      --same-bg: rgba(236, 72, 153, 0.2);
      --same-border: rgba(236, 72, 153, 0.85);
      --same-text: #fb7185;
    }

    body.theme-neonyellow {
      --bg: #020617;
      --card: #020617;
      --accent: #facc15;
      --grid-line: #facc15;
      --grid-sub: #fde047;
      --text: #fefce8;
      --muted: #e5e7eb;
      --error: #fb7185;
      --given: #fefce8;
      --cell-bg: #020617;
      --cell-selected: #facc15;
      --cell-related: #020617;
      --same-bg: rgba(250, 204, 21, 0.25);
      --same-border: rgba(250, 204, 21, 0.9);
      --same-text: #facc15;
    }

    body.theme-bright {
      --bg: #e5e7eb;
      --card: #f9fafb;
      --accent: #2563eb;
      --grid-line: #d1d5db;
      --grid-sub: #9ca3af;
      --text: #111827;
      --muted: #6b7280;
      --error: #b91c1c;
      --given: #111827;
      --cell-bg: #ffffff;
      --cell-selected: #2563eb;
      --cell-related: #e5e7eb;
      --same-bg: rgba(37, 99, 235, 0.15);
      --same-border: rgba(37, 99, 235, 0.8);
      --same-text: #1d4ed8;
    }

    body.theme-paper {
      --bg: #fef9c3;
      --card: #fffbeb;
      --accent: #b45309;
      --grid-line: #d97706;
      --grid-sub: #92400e;
      --text: #1f2937;
      --muted: #6b7280;
      --error: #b91c1c;
      --given: #1f2937;
      --cell-bg: #fffbeb;
      --cell-selected: #f59e0b;
      --cell-related: #fef3c7;
      --same-bg: rgba(245, 158, 11, 0.2);
      --same-border: rgba(217, 119, 6, 0.85);
      --same-text: #b45309;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #1f2937, #020617 55%);
      color: var(--text);
    }

    .app {
      width: 100%;
      max-width: 420px;
      padding: 16px;
      position: relative;
    }

    .card {
      background: linear-gradient(145deg, var(--card), #030712);
      border-radius: 18px;
      padding: 16px 14px 18px;
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(148, 163, 184, 0.08);
    }

    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .title-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    h1 {
      font-size: 18px;
      margin: 0;
      letter-spacing: 0.03em;
    }

    .subtitle {
      font-size: 11px;
      color: var(--muted);
    }

    #versionTag {
      font-size: 11px;
      color: var(--muted);
      margin-left: 4px;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    select, button { font: inherit; }

    .select-wrap {
      flex: 1;
      min-width: 0;
      position: relative;
    }

    .select-wrap select {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.85);
      color: var(--text);
      font-size: 12px;
      outline: none;
      appearance: none;
    }

    body.theme-bright .select-wrap select,
    body.theme-paper .select-wrap select {
      background: rgba(249, 250, 251, 0.95);
      color: #111827;
    }

    .select-wrap::after {
      content: "â–¾";
      position: absolute;
      right: 9px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      color: var(--muted);
      pointer-events: none;
    }

    .btn-pill {
      border-radius: 999px;
      border: none;
      padding: 7px 14px;
      font-size: 12px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-weight: 600;
      color: #020617;
      background: linear-gradient(135deg, #facc15, #f97316);
      box-shadow:
        0 0 0 1px rgba(250, 204, 21, 0.3),
        0 10px 20px rgba(248, 181, 0, 0.3);
      white-space: nowrap;
    }

    .btn-pill:active {
      transform: translateY(1px);
      box-shadow:
        0 0 0 1px rgba(250, 204, 21, 0.3),
        0 4px 12px rgba(248, 181, 0, 0.4);
    }

    .info-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 11px;
      color: var(--muted);
    }

    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    body.theme-bright .badge,
    body.theme-paper .badge {
      background: rgba(249, 250, 251, 0.95);
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2);
    }

    .timer {
      font-variant-numeric: tabular-nums;
    }

    /* GRID */

    .grid-wrap {
      padding: 10px;
      border-radius: 12px;
      background: radial-gradient(circle at top, var(--card), #030712);
      box-shadow: inset 0 0 0 1px rgba(75, 85, 99, 0.3);
      position: relative;
    }

    body.theme-bright .grid-wrap,
    body.theme-paper .grid-wrap {
      background: var(--card);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.6);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      border-radius: 10px;
      overflow: hidden;
      background: var(--bg);
      box-shadow: inset 0 0 0 1px var(--grid-sub);
    }

    .cell {
      width: 100%;
      padding-top: 100%;
      position: relative;
      border: 0;
      background: var(--cell-bg);
      font-size: 18px;
      font-weight: 500;
      color: var(--text);
      text-align: center;
      cursor: pointer;
    }

    .cell-inner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .cell:nth-child(3n+1) {
      border-left: 1px solid var(--grid-sub);
    }

    .cell:nth-child(-n+9) {
      border-top: 1px solid var(--grid-sub);
    }

    .cell {
      border-right: 1px solid var(--grid-line);
      border-bottom: 1px solid var(--grid-line);
    }

    .cell[data-col="2"],
    .cell[data-col="5"] {
      border-right: 2px solid var(--grid-sub);
    }

    .cell[data-row="2"],
    .cell[data-row="5"] {
      border-bottom: 2px solid var(--grid-sub);
    }

    .cell.given {
      background: var(--cell-bg);
      color: var(--given);
      font-weight: 700;
    }

    .cell.empty {
      color: var(--muted);
    }

    .cell.selected {
      background: linear-gradient(145deg, var(--cell-selected), #0f172a);
      color: #fefce8;
    }

    .cell.related:not(.selected) {
      background: var(--cell-related);
    }

    .cell.same-value:not(.selected) {
      background: var(--same-bg);
      box-shadow: inset 0 0 0 1px var(--same-border);
      color: var(--same-text);
      font-weight: 700;
    }

    .cell.conflict {
      color: var(--error);
      text-shadow: 0 0 6px rgba(248, 113, 113, 0.6);
    }

    .cell:active {
      filter: brightness(1.08);
    }

    /* Completion flash wave */
@keyframes flashWave {
  0% {
    transform: scale(1);
    box-shadow: none;
  }
  30% {
    transform: scale(1.06);
    box-shadow: 0 0 18px rgba(250, 204, 21, 0.95);
  }
  60% {
    transform: scale(0.98);
    box-shadow: 0 0 6px rgba(15, 23, 42, 0.6);
  }
  100% {
    transform: scale(1);
    box-shadow: none;
  }
}

.cell.flash-wave {
  animation: flashWave 550ms ease-in-out forwards;
}


    .cell.twinkle {
      animation: twinkle 0.7s ease-in-out forwards;
    }

    /* POPUP PAD */

    .popup-pad {
      position: absolute;
      transform: translate(-50%, -50%);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.96);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
      z-index: 5;
    }

    body.theme-bright .popup-pad,
    body.theme-paper .popup-pad {
      background: rgba(249, 250, 251, 0.98);
      box-shadow: 0 10px 25px rgba(148, 163, 184, 0.9);
    }

    .popup-btn {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: var(--cell-bg);
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
    }

    .popup-btn:active { transform: translateY(1px); }

    /* PAD */

    .pad {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
    }

    .pad-btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text);
      padding: 10px 0;
      font-size: 16px;
      font-weight: 500;
      transition: opacity 0.15s ease;
    }

    body.theme-bright .pad-btn,
    body.theme-paper .pad-btn {
      background: #f9fafb;
      color: #111827;
    }

    .pad-btn.small {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      font-weight: 600;
    }

    .pad-btn.primary {
      border-color: rgba(251, 191, 36, 0.7);
      background: radial-gradient(circle at top, #facc15, #f97316);
      color: #020617;
      font-weight: 700;
      box-shadow:
        0 0 0 1px rgba(250, 204, 21, 0.5),
        0 10px 18px rgba(248, 181, 0, 0.4);
    }

    .pad-btn.toggled {
      background: rgba(37, 99, 235, 0.1);
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .pad-btn.hidden-num {
      opacity: 0.15;
      pointer-events: none;
    }

    .pad-btn:active { transform: translateY(1px); }

    .footer {
      margin-top: 10px;
      text-align: center;
      font-size: 10px;
      color: var(--muted);
    }

    .footer b {
      color: var(--accent);
      font-weight: 600;
    }

    .stats-link {
      margin-top: 6px;
      text-align: center;
    }

    .stats-btn {
      background: none;
      border: none;
      padding: 4px 8px;
      font-size: 11px;
      color: var(--muted);
      text-decoration: underline;
      cursor: pointer;
    }

    .stats-btn:active { transform: translateY(1px); }

    /* STATS OVERLAY */

    .stats-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .stats-card {
      width: 90%;
      max-width: 360px;
      background: var(--card);
      border-radius: 16px;
      padding: 16px 16px 14px;
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(148, 163, 184, 0.3);
    }

    .stats-card h2 {
      margin: 0 0 4px;
      font-size: 16px;
    }

    #statsVersion {
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .stats-sub {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-bottom: 8px;
    }

    .stats-table th,
    .stats-table td {
      padding: 4px 3px;
      text-align: center;
    }

    .stats-table th {
      color: var(--muted);
      font-weight: 600;
      border-bottom: 1px solid rgba(148, 163, 184, 0.4);
    }

    .stats-table td {
      border-bottom: 1px solid rgba(55, 65, 81, 0.4);
    }

    .stats-footer {
      font-size: 10px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
      gap: 6px;
    }

    .stats-close {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      font-size: 11px;
      padding: 4px 10px;
    }

    .hidden { display: none !important; }

    /* Make conflicts extra obvious in Neon Pink */
    body.theme-neonpink .cell.conflict {
      background: rgba(250, 204, 21, 0.3);
      color: #fef9c3;
      box-shadow: 0 0 14px rgba(250, 204, 21, 0.95);
    }

    @media (max-width: 360px) {
      .card { padding: 12px 10px 14px; }
      .cell { font-size: 16px; }
      .pad-btn { padding: 8px 0; }
      .popup-btn { width: 28px; height: 28px; font-size: 13px; }
    }
  </style>
</head>
<body class="theme-neon">
<div class="app">
  <div class="card">
    <div class="header-row">
      <div class="title-group">
        <h1>Sudoku</h1>
        <div class="subtitle">
          Ad-free. Just numbers and logic.
          <span id="versionTag"></span>
        </div>
      </div>
    </div>

    <div class="controls-row">
      <div class="select-wrap">
        <select id="difficulty">
          <option value="easy" selected>Easy</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>
      <div class="select-wrap">
        <select id="themeSelect">
          <option value="neon" selected>Neon Green</option>
          <option value="neonpink">Neon Pink</option>
          <option value="neonyellow">Neon Yellow</option>
          <option value="classic">Classic Dark</option>
          <option value="bright">Bright</option>
          <option value="paper">Paper</option>
        </select>
      </div>
      <button id="newGameBtn" class="btn-pill">New Puzzle</button>
    </div>

    <div class="info-row">
      <div class="badge">
        <span class="badge-dot"></span>
        <span id="statusText">In progress</span>
      </div>
      <div class="timer" id="timer">00:00</div>
    </div>

    <div class="grid-wrap">
      <div id="grid" class="grid"></div>

      <!-- popup pad -->
      <div id="popupPad" class="popup-pad hidden">
        <button class="popup-btn" data-num="1">1</button>
        <button class="popup-btn" data-num="2">2</button>
        <button class="popup-btn" data-num="3">3</button>
        <button class="popup-btn" data-num="4">4</button>
        <button class="popup-btn" data-num="5">5</button>
        <button class="popup-btn" data-num="6">6</button>
        <button class="popup-btn" data-num="7">7</button>
        <button class="popup-btn" data-num="8">8</button>
        <button class="popup-btn" data-num="9">9</button>
      </div>
    </div>

    <div class="pad">
      <button class="pad-btn" data-num="1">1</button>
      <button class="pad-btn" data-num="2">2</button>
      <button class="pad-btn" data-num="3">3</button>
      <button class="pad-btn" data-num="4">4</button>
      <button class="pad-btn" data-num="5">5</button>
      <button class="pad-btn" data-num="6">6</button>
      <button class="pad-btn" data-num="7">7</button>
      <button class="pad-btn" data-num="8">8</button>
      <button class="pad-btn" data-num="9">9</button>
      <button class="pad-btn small" id="eraseBtn">Erase</button>
      <button class="pad-btn small" id="notesBtn">Notes</button>
      <button class="pad-btn small" id="clearNotesBtn">Clr Notes</button>
      <button class="pad-btn small" id="checkBtn">Check</button>
      <button class="pad-btn small primary" id="hintBtn">Hint</button>
    </div>

    <div class="footer">
      Progress is saved locally on this device. <b>No ads. No accounts.</b>
    </div>
    <div class="stats-link">
      <button id="statsBtn" class="stats-btn">Stats</button>
    </div>
  </div>

  <!-- Stats overlay -->
  <div id="statsOverlay" class="stats-overlay hidden">
    <div class="stats-card">
      <h2>Stats</h2>
      <div id="statsVersion"></div>
      <div class="stats-sub">
        Tracked per difficulty on this device only.
      </div>
      <div id="statsBadges" class="stats-sub"></div>
      <table class="stats-table">
        <thead>
          <tr>
            <th>Level</th>
            <th>Games</th>
            <th>Best</th>
            <th>Avg</th>
            <th>Worst</th>
          </tr>
        </thead>
        <tbody id="statsBody"></tbody>
      </table>
      <div class="stats-footer">
        <span id="statsSummary"></span>
        <button id="closeStatsBtn" class="stats-close">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
  const APP_VERSION = "v0.4";

  const STATS_KEY = "sudokuStatsV2";
  const STATE_KEY = "sudokuStateV2";
  const THEME_KEY = "sudokuThemeV1";

  // show version tags
  document.getElementById("versionTag").textContent = "Â· " + APP_VERSION;
  document.getElementById("statsVersion").textContent = "Version " + APP_VERSION;

  // Multiple puzzles per difficulty (random pick each time)
  const PUZZLES = {
    easy: [
      "791020506350006090268951034430065000806070340900013000000007200000542079570000003",
      "600070010040130000081000205092080003308020197406001000863009021007243568520000370",
      "690082407004300005578614090000240030439000600010906054200001503381465200050000000",
      "190006050060930017032001690005200004003897065270500030047600100021070000356040720"
    ],
    medium: [
      "000000800501000070700058030460010093809200010000070068900046002350107900076000040",
      "900762000200000901580004002000000750002047000000090014009080100710020460420600305",
      "052000041700609300008005000007961000306004020405082107000090700800000005020007083",
      "500029000009700002000510007100078090090040001460000028050096703000000009036207504"
    ],
    hard: [
      "000006000006053009590000400030700050002900010008305006009000000800000003005078091",
      "003709002600500000005080301000073090030000020900068503470000000060900000000040009",
      "000003400150000200000020073000400000040038001008060300000002040039070028200051000",
      "039000000070002904000000010000400090008001700014503800020010000005600000800004167"
    ]
  };

  // Game state
  let board = new Array(81).fill(0);
  let given = new Array(81).fill(false);
  let notes = Array.from({ length: 81 }, () => new Set());
  let selectedIndex = null;
  let notesMode = false;
  let startTime = null;
  let timerInterval = null;
  let currentDifficulty = "easy";
  let currentTheme = "neon";
  let currentPuzzleStr = null;
  let solution = null;

  // Per-game flags for badges
  let gameUsedHint = false;
  let gameMadeError = false;

  // Stats state (per difficulty + meta)
  let stats = {
    easy:   { games: 0, totalSeconds: 0, bestSeconds: null, worstSeconds: null },
    medium: { games: 0, totalSeconds: 0, bestSeconds: null, worstSeconds: null },
    hard:   { games: 0, totalSeconds: 0, bestSeconds: null, worstSeconds: null },
    meta: {
      currentStreak: 0,
      longestStreak: 0,
      lastPlayedDate: null,
      noHintWins: 0,
      noErrorWins: 0,
      perfectWins: 0
    }
  };

  const gridEl = document.getElementById("grid");
  const difficultyEl = document.getElementById("difficulty");
  const themeSelect = document.getElementById("themeSelect");
  const newGameBtn = document.getElementById("newGameBtn");
  const statusText = document.getElementById("statusText");
  const timerEl = document.getElementById("timer");
  const eraseBtn = document.getElementById("eraseBtn");
  const notesBtn = document.getElementById("notesBtn");
  const clearNotesBtn = document.getElementById("clearNotesBtn");
  const checkBtn = document.getElementById("checkBtn");
  const hintBtn = document.getElementById("hintBtn");
  const popupPad = document.getElementById("popupPad");
  const padButtons = document.querySelectorAll(".pad-btn[data-num]");
  const statsOverlay = document.getElementById("statsOverlay");
  const statsBody = document.getElementById("statsBody");
  const statsSummary = document.getElementById("statsSummary");
  const statsBadges = document.getElementById("statsBadges");
  const statsBtn = document.getElementById("statsBtn");
  const closeStatsBtn = document.getElementById("closeStatsBtn");

  /* THEME */

  function applyTheme(theme) {
    const all = ["classic","neon","neonpink","neonyellow","bright","paper"];
    all.forEach(t => document.body.classList.remove("theme-" + t));
    document.body.classList.add("theme-" + theme);
  }

  function loadTheme() {
    const saved = localStorage.getItem(THEME_KEY);
    if (saved) {
      currentTheme = saved;
      applyTheme(saved);
      themeSelect.value = saved;
    } else {
      applyTheme(currentTheme);
      themeSelect.value = currentTheme;
    }
  }

  function saveTheme() {
    localStorage.setItem(THEME_KEY, currentTheme);
  }

  themeSelect.addEventListener("change", () => {
    currentTheme = themeSelect.value;
    applyTheme(currentTheme);
    saveTheme();
  });

  /* UTILS */

  function indexToRC(i) {
    return { row: Math.floor(i / 9), col: i % 9 };
  }

  function rcToIndex(r, c) {
    return r * 9 + c;
  }

  function puzzleStringToBoard(str) {
    const b = new Array(81).fill(0);
    for (let i = 0; i < 81; i++) {
      const c = str[i] || "0";
      b[i] = (c === "0" || c === ".") ? 0 : parseInt(c, 10);
    }
    return b;
  }

  function cloneBoard(b) {
    return b.slice();
  }

  function isValidValue(b, index, value) {
    if (value === 0) return true;
    const { row, col } = indexToRC(index);

    // row
    for (let c = 0; c < 9; c++) {
      const idx = rcToIndex(row, c);
      if (idx !== index && b[idx] === value) return false;
    }
    // col
    for (let r = 0; r < 9; r++) {
      const idx = rcToIndex(r, col);
      if (idx !== index && b[idx] === value) return false;
    }
    // box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        const idx = rcToIndex(boxRow + r, boxCol + c);
        if (idx !== index && b[idx] === value) return false;
      }
    }
    return true;
  }

  function isValidPlacement(index, value) {
    return isValidValue(board, index, value);
  }

  /* SOLVER */

  function solveSudoku(initialBoard) {
    const b = cloneBoard(initialBoard);

    function findEmpty() {
      for (let i = 0; i < 81; i++) if (b[i] === 0) return i;
      return -1;
    }

    function backtrack() {
      const idx = findEmpty();
      if (idx === -1) return true;

      for (let num = 1; num <= 9; num++) {
        if (isValidValue(b, idx, num)) {
          b[idx] = num;
          if (backtrack()) return true;
          b[idx] = 0;
        }
      }
      return false;
    }

    if (backtrack()) return b;
    return null;
  }

  /* TIMER */

  function startTimer() {
    startTime = Date.now();
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(updateTimer, 1000);
    updateTimer();
  }

  function updateTimer() {
    if (!startTime) {
      timerEl.textContent = "00:00";
      return;
    }
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const m = String(Math.floor(elapsed / 60)).padStart(2, "0");
    const s = String(elapsed % 60).padStart(2, "0");
    timerEl.textContent = m + ":" + s;
  }

  /* STATS */

  function loadStats() {
    try {
      const raw = localStorage.getItem(STATS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed.easy || !parsed.medium || !parsed.hard) return;

      if (!parsed.meta) {
        parsed.meta = {
          currentStreak: 0,
          longestStreak: 0,
          lastPlayedDate: null,
          noHintWins: 0,
          noErrorWins: 0,
          perfectWins: 0
        };
      }
      stats = parsed;
    } catch (e) {}
  }

  function saveStats() {
    try {
      localStorage.setItem(STATS_KEY, JSON.stringify(stats));
    } catch (e) {}
  }

  function recordCompletion(diff, seconds, usedHint, madeError) {
    const s = stats[diff];
    if (!s) return;
    s.games++;
    s.totalSeconds += seconds;
    if (s.bestSeconds === null || seconds < s.bestSeconds) s.bestSeconds = seconds;
    if (s.worstSeconds === null || seconds > s.worstSeconds) s.worstSeconds = seconds;

    const meta = stats.meta || (stats.meta = {
      currentStreak: 0,
      longestStreak: 0,
      lastPlayedDate: null,
      noHintWins: 0,
      noErrorWins: 0,
      perfectWins: 0
    });

    const today = new Date();
    const todayStr = today.toISOString().slice(0, 10);

    if (!meta.lastPlayedDate) {
      meta.currentStreak = 1;
    } else {
      const last = new Date(meta.lastPlayedDate);
      const diffMs = today.setHours(0,0,0,0) - last.setHours(0,0,0,0);
      const diffDays = Math.floor(diffMs / 86400000);
      if (diffDays === 0) {
        // same day; streak unchanged
      } else if (diffDays === 1) {
        meta.currentStreak = (meta.currentStreak || 0) + 1;
      } else {
        meta.currentStreak = 1;
      }
    }
    meta.longestStreak = Math.max(meta.longestStreak || 0, meta.currentStreak);
    meta.lastPlayedDate = todayStr;

    if (!usedHint) meta.noHintWins = (meta.noHintWins || 0) + 1;
    if (!madeError) meta.noErrorWins = (meta.noErrorWins || 0) + 1;
    if (!usedHint && !madeError) meta.perfectWins = (meta.perfectWins || 0) + 1;

    saveStats();
  }

  function formatSeconds(sec) {
    if (sec === null || sec === undefined) return "â€”";
    const s = Math.max(0, Math.floor(sec));
    const m = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${m}:${ss}`;
  }

  function updateStatsOverlay() {
    const diffs = ["easy","medium","hard"];
    const labels = { easy: "Easy", medium: "Medium", hard: "Hard" };
    let totalGames = 0;
    statsBody.innerHTML = "";

    diffs.forEach(d => {
      const s = stats[d];
      totalGames += s.games;
      const avg = s.games ? s.totalSeconds / s.games : null;
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${labels[d]}</td>
        <td>${s.games}</td>
        <td>${formatSeconds(s.bestSeconds)}</td>
        <td>${formatSeconds(avg)}</td>
        <td>${formatSeconds(s.worstSeconds)}</td>
      `;
      statsBody.appendChild(tr);
    });

    const meta = stats.meta || {};
    const currentStreak = meta.currentStreak || 0;
    const longestStreak = meta.longestStreak || 0;
    const noHintWins = meta.noHintWins || 0;
    const noErrorWins = meta.noErrorWins || 0;
    const perfectWins = meta.perfectWins || 0;

    statsSummary.textContent =
      `Total games: ${totalGames} â€¢ Streak: ${currentStreak} day(s) (Best: ${longestStreak})`;

    statsBadges.textContent =
      `Badges â€“ No Hints: ${noHintWins} â€¢ No Errors: ${noErrorWins} â€¢ Perfect: ${perfectWins}`;
  }

  statsBtn.addEventListener("click", () => {
    updateStatsOverlay();
    statsOverlay.classList.remove("hidden");
  });

  closeStatsBtn.addEventListener("click", () => {
    statsOverlay.classList.add("hidden");
  });

  statsOverlay.addEventListener("click", (e) => {
    if (e.target === statsOverlay) statsOverlay.classList.add("hidden");
  });

  /* STATE LOAD/SAVE */

  function saveState() {
    try {
      const state = {
        board,
        given,
        notes: notes.map(s => Array.from(s)),
        difficulty: currentDifficulty,
        theme: currentTheme,
        puzzle: currentPuzzleStr,
        startTime,
        gameUsedHint,
        gameMadeError
      };
      localStorage.setItem(STATE_KEY, JSON.stringify(state));
    } catch (e) {}
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STATE_KEY);
      if (!raw) return false;
      const state = JSON.parse(raw);
      board = state.board || board;
      given = state.given || given;
      notes = (state.notes || []).map(arr => new Set(arr));
      currentDifficulty = state.difficulty || "easy";
      currentPuzzleStr = state.puzzle || null;
      difficultyEl.value = currentDifficulty;

      if (currentPuzzleStr) {
        const base = puzzleStringToBoard(currentPuzzleStr);
        solution = solveSudoku(base);
      }

      if (state.startTime) {
        startTime = state.startTime;
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
        updateTimer();
      }

      gameUsedHint = !!state.gameUsedHint;
      gameMadeError = !!state.gameMadeError;

      statusText.textContent = "Resumed game";
      return true;
    } catch (e) {
      return false;
    }
  }

  /* PUZZLE INIT */

  function loadRandomPuzzle(diff) {
    const arr = PUZZLES[diff];
    const puzzle = arr[Math.floor(Math.random() * arr.length)];
    currentPuzzleStr = puzzle;

    const base = puzzleStringToBoard(puzzle);
    board = cloneBoard(base);
    given = new Array(81).fill(false);
    notes = Array.from({ length: 81 }, () => new Set());

    for (let i = 0; i < 81; i++) {
      if (base[i] !== 0) given[i] = true;
    }

    solution = solveSudoku(base);
    selectedIndex = null;
    notesMode = false;
    notesBtn.classList.remove("toggled");
    hidePopupPad();
    startTimer();
    statusText.textContent = "In progress";
    gameUsedHint = false;
    gameMadeError = false;
    saveState();
    render();
  }

  /* LOGIC HELPERS */

  function findRuleConflicts() {
    const conflicts = new Set();

    // rows
    for (let r = 0; r < 9; r++) {
      const seen = {};
      for (let c = 0; c < 9; c++) {
        const idx = rcToIndex(r, c);
        const v = board[idx];
        if (!v) continue;
        if (seen[v] !== undefined) {
          conflicts.add(idx);
          conflicts.add(seen[v]);
        } else {
          seen[v] = idx;
        }
      }
    }

    // cols
    for (let c = 0; c < 9; c++) {
      const seen = {};
      for (let r = 0; r < 9; r++) {
        const idx = rcToIndex(r, c);
        const v = board[idx];
        if (!v) continue;
        if (seen[v] !== undefined) {
          conflicts.add(idx);
          conflicts.add(seen[v]);
        } else {
          seen[v] = idx;
        }
      }
    }

    // boxes
    for (let br = 0; br < 3; br++) {
      for (let bc = 0; bc < 3; bc++) {
        const seen = {};
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const idx = rcToIndex(br * 3 + r, bc * 3 + c);
            const v = board[idx];
            if (!v) continue;
            if (seen[v] !== undefined) {
              conflicts.add(idx);
              conflicts.add(seen[v]);
            } else {
              seen[v] = idx;
            }
          }
        }
      }
    }

    return conflicts;
  }

  function clearDigitFromPeers(index, digit) {
    const { row, col } = indexToRC(index);

    // row
    for (let c = 0; c < 9; c++) {
      const idx = rcToIndex(row, c);
      if (idx !== index) notes[idx].delete(digit);
    }
    // col
    for (let r = 0; r < 9; r++) {
      const idx = rcToIndex(r, col);
      if (idx !== index) notes[idx].delete(digit);
    }
    // box
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        const idx = rcToIndex(boxRow + r, boxCol + c);
        if (idx !== index) notes[idx].delete(digit);
      }
    }
  }

  function isSolvedCompletely() {
    if (!solution) return false;
    for (let i = 0; i < 81; i++) {
      if (board[i] !== solution[i]) return false;
    }
    return true;
  }

  /* POPUP PAD */

  function hidePopupPad() {
    popupPad.classList.add("hidden");
  }

  function showPopupPad(cellEl) {
    const gridRect = gridEl.getBoundingClientRect();
    const cellRect = cellEl.getBoundingClientRect();
    const x = cellRect.left + cellRect.width / 2 - gridRect.left;
    const y = cellRect.top + cellRect.height / 2 - gridRect.top;
    popupPad.style.left = x + "px";
    popupPad.style.top = y + "px";
    popupPad.classList.remove("hidden");
  }

  gridEl.addEventListener("click", (e) => {
    if (!popupPad.contains(e.target) && !e.target.classList.contains("cell")) {
      hidePopupPad();
    }
  });

  /* COMPLETION ANIMATION */

  function celebrateWin() {
  const cells = Array.from(gridEl.children);

  // group cells by 3Ã—3 box
  const boxes = Array.from({ length: 9 }, () => []);

  cells.forEach((cell, index) => {
    const row = Math.floor(index / 9);
    const col = index % 9;
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    boxes[boxIndex].push(cell);
  });

  // flash boxes one after another
  boxes.forEach((boxCells, boxIndex) => {
    setTimeout(() => {
      boxCells.forEach(cell => {
        cell.classList.add("flash-wave");
        setTimeout(() => {
          cell.classList.remove("flash-wave");
        }, 600);
      });
    }, boxIndex * 140); // delay between boxes
  });
}


  /* INPUT HANDLERS */

  function handleCellTap(index, cellEl) {
    selectedIndex = index;
    const editableBlank = !given[index] && board[index] === 0;
    render();
    if (editableBlank && !notesMode && cellEl) {
      showPopupPad(cellEl);
    } else {
      hidePopupPad();
    }
  }

  function handleNumberTap(num) {
    if (selectedIndex === null) return;
    if (given[selectedIndex]) return;

    const idx = selectedIndex;

    // NOTES MODE â€“ pencil marks only
    if (notesMode) {
      const set = notes[idx];
      if (set.has(num)) set.delete(num);
      else set.add(num);
      board[idx] = 0;
      statusText.textContent = "Notes updated";
      hidePopupPad();
      saveState();
      render();
      return;
    }

    // NORMAL MODE â€“ strict "no mistakes"
    board[idx] = num;

    // 1) Rule conflicts (row/column/box)
    const conflicts = findRuleConflicts();

    // 2) Solution-based conflict (wrong number even if rules OK)
    if (solution && board[idx] !== solution[idx]) {
      conflicts.add(idx);
    }

    if (conflicts.size > 0) {
      // Wrong move: keep the number, show in red
      gameMadeError = true;
      statusText.textContent = "That number can't go there.";
      hidePopupPad();
      saveState();
      render(conflicts);
      return;
    }

    // Valid move
    notes[idx].clear();
    clearDigitFromPeers(idx, num);

    if (isSolvedCompletely()) {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      recordCompletion(currentDifficulty, elapsed, gameUsedHint, gameMadeError);
      statusText.textContent = "Completed ðŸŽ‰";
      if (timerInterval) clearInterval(timerInterval);
      celebrateWin();
    } else {
      statusText.textContent = "In progress";
    }

    hidePopupPad();
    saveState();
    render();
  }

  function handleErase() {
    if (selectedIndex === null) return;
    if (given[selectedIndex]) return;
    board[selectedIndex] = 0;
    notes[selectedIndex].clear();
    statusText.textContent = "In progress";
    hidePopupPad();
    saveState();
    render();
  }

  function handleCheck() {
    const ruleConflicts = findRuleConflicts();
    const allConflicts = new Set(ruleConflicts);

    if (solution) {
      for (let i = 0; i < 81; i++) {
        if (board[i] !== 0 && board[i] !== solution[i]) {
          allConflicts.add(i);
        }
      }
    }

    if (allConflicts.size === 0) {
      statusText.textContent = "No conflicts so far âœ…";
    } else {
      statusText.textContent = `${allConflicts.size} issue(s) found â—`;
    }
    render(allConflicts);
  }

  function handleHint() {
    if (selectedIndex === null || given[selectedIndex]) return;
    if (board[selectedIndex] !== 0) return;
    if (!solution) return;

    board[selectedIndex] = solution[selectedIndex];
    notes[selectedIndex].clear();
    clearDigitFromPeers(selectedIndex, board[selectedIndex]);
    gameUsedHint = true;
    statusText.textContent = "Hint applied ðŸ’¡";

    if (isSolvedCompletely()) {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      recordCompletion(currentDifficulty, elapsed, gameUsedHint, gameMadeError);
      statusText.textContent = "Completed ðŸŽ‰";
      if (timerInterval) clearInterval(timerInterval);
      celebrateWin();
    }

    saveState();
    render();
  }

  function toggleNotesMode() {
    notesMode = !notesMode;
    notesBtn.classList.toggle("toggled", notesMode);
    hidePopupPad();
    render();
  }

  function clearNotes() {
    if (selectedIndex === null) return;
    notes[selectedIndex].clear();
    saveState();
    render();
  }

  /* RENDERING */

  function updatePadVisibility() {
    const counts = Array(10).fill(0);

    for (let i = 0; i < 81; i++) {
      const v = board[i];
      if (!v) continue;

      if (solution) {
        if (v === solution[i]) counts[v]++;
      } else {
        counts[v]++;
      }
    }

    padButtons.forEach(btn => {
      const num = parseInt(btn.dataset.num, 10);
      if (!notesMode && counts[num] >= 9) {
        btn.classList.add("hidden-num");
      } else {
        btn.classList.remove("hidden-num");
      }
    });
  }

  function render(conflictsOverride) {
    gridEl.innerHTML = "";
    const conflicts = conflictsOverride || findRuleConflicts();
    const selectedVal = selectedIndex !== null ? board[selectedIndex] : null;

    for (let i = 0; i < 81; i++) {
      const cell = document.createElement("button");
      cell.className = "cell";
      const { row, col } = indexToRC(i);
      cell.dataset.row = row;
      cell.dataset.col = col;

      const inner = document.createElement("div");
      inner.className = "cell-inner";

      if (given[i]) {
        cell.classList.add("given");
      } else if (board[i] === 0 && notes[i].size === 0) {
        cell.classList.add("empty");
      }

      if (board[i] !== 0) {
        inner.textContent = board[i];
      } else if (notes[i].size > 0) {
        const small = document.createElement("div");
        small.style.fontSize = "11px";
        small.style.lineHeight = "1.1";
        small.style.opacity = "0.9";
        small.style.display = "grid";
        small.style.gridTemplateColumns = "repeat(3, 1fr)";
        small.style.width = "95%";
        small.style.height = "95%";
        for (let n = 1; n <= 9; n++) {
          const span = document.createElement("span");
          span.style.fontSize = "10px";
          span.style.opacity = notes[i].has(n) ? "1" : "0.18";
          span.textContent = notes[i].has(n) ? n : " ";
          small.appendChild(span);
        }
        inner.appendChild(small);
      } else {
        inner.textContent = "";
      }

      if (i === selectedIndex) {
        cell.classList.add("selected");
      } else if (selectedIndex !== null) {
        const { row: sr, col: sc } = indexToRC(selectedIndex);
        if (row === sr || col === sc ||
            (Math.floor(row / 3) === Math.floor(sr / 3) &&
             Math.floor(col / 3) === Math.floor(sc / 3))) {
          cell.classList.add("related");
        }
      }

      if (selectedVal && board[i] === selectedVal && i !== selectedIndex) {
        cell.classList.add("same-value");
      }

      if (conflicts.has(i)) {
        cell.classList.add("conflict");
      }

      cell.addEventListener("click", (evt) => handleCellTap(i, evt.currentTarget));
      cell.appendChild(inner);
      gridEl.appendChild(cell);
    }

    updatePadVisibility();
  }

  /* EVENTS */

  difficultyEl.addEventListener("change", () => {
    currentDifficulty = difficultyEl.value;
  });

  newGameBtn.addEventListener("click", () => {
    loadRandomPuzzle(currentDifficulty);
  });

  padButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const num = parseInt(btn.dataset.num, 10);
      handleNumberTap(num);
    });
  });

  popupPad.querySelectorAll(".popup-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const num = parseInt(btn.dataset.num, 10);
      handleNumberTap(num);
    });
  });

  eraseBtn.addEventListener("click", handleErase);
  notesBtn.addEventListener("click", toggleNotesMode);
  clearNotesBtn.addEventListener("click", clearNotes);
  checkBtn.addEventListener("click", handleCheck);
  hintBtn.addEventListener("click", handleHint);

  /* INIT */

  loadTheme();
  loadStats();

  if (!loadState()) {
    loadRandomPuzzle(currentDifficulty);
  } else {
    render();
  }
</script>
</body>
</html>
